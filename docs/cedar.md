# CEDAR

## What is CEDAR

The CMS Enterprise Data and Analytics Repository (CEDAR) is a collection of APIs and databases that serve to collect and store data that describes CMS Business Processes and applications.

[CEDAR's Confluence Space](https://confluence.cms.gov/pages/viewpage.action?pageId=319959581)

## Local Prerequisites

In order to browse the CEDAR UI you'll need to meet a few prerequisites:

1. A running connection to the CMS VPN
1. [Edits to your local Root certificates](https://confluence.cms.gov/display/CEDAR/Updating+your+local+workstations+Root+Certificates)
1. The following edits to your [hosts file](https://en.wikipedia.org/wiki/Hosts_(file))

```
10.138.78.45 cedarimpl.cms.gov aris.cedarimpl.cms.gov alfabet.cedarimpl.cms.gov webmethods-apigw.cedarimpl.cms.gov webmethods-apiportal.cedarimpl.cms.gov www.cedarimpl.cms.gov aris.cedarimpl.cms.gov alfabet.cedarimpl.cms.gov webmethods-apigw.cedarimpl.cms.gov 
10.245.38.21 www.cedar.cms.gov cedar.cms.gov aris.cedar.cms.gov alfabet.cedar.cms.gov webmethods-apigw.cedar.cms.gov webmethods-apiportal.cedar.cms.gov
```

## CEDAR UI

The CEDAR web UI (where you can view documentation, try out APIs, and browse data in Alfabet). It can be accessed from the following URLs for each environment

- IMPL: https://www.cedarimpl.cms.gov/
- PROD: https://www.cedar.cms.gov/

### webMethods API Portal

The webMethods API Portal is where you can view CEDARs API documentation, and is probably the most useful tool for developers. Once you're there, you can click "API Gallery" at the top of the page to view the details of each CEDAR API.

### Alfabet

Alfabet is the backend API that stores the data that CEDAR pulls from. EASi does not integrate directly with Alfabet, but uses CEDAR as a proxy to Alfabet.

However, you can click Alfabet on the main CEDAR UI page to see the Alfabet UI, which lets you browse the data in Alfabet. Do _NOT_ modify any data directly in Alfabet.

## How is CEDAR accessed within EASi?

The calls that are made to the CEDAR APIs are defined by code generated by `go-swagger`. However, in order to not have changes to the CEDAR API documentation break EASi, a "translated client" is usually created for each CEDAR API that wraps the generated code with our own, tested client. An example of this is the [pkg/cedar/intake/client.go](../pkg/cedar/intake/client.go) file.

### Code Generation

The Go code is generated by a tool called `go-swagger`. This is a different tool from the Go generator in swagger codegen, and is a standalone tool. How we use this tool (and what version) is documented [here](./dev_environment_setup.md#go-swagger).

For CEDAR Core, this tool is not executed as part of any build process, and should be run manually when new swagger files are added. From the `pkg/cedar/core` directory:

```terminal
swagger generate client -f cedar_core.yml -c ./gen/client -m ./gen/models
```

CEDAR LDAP is similar, just in the `pkg/cedar/cedarldap` directory:

```terminal
swagger generate client -f swagger-impl.json -c ./gen/client -m ./gen/models
```

The CEDAR Intake Swagger file requires a bit of preprocessing before code generation. When the Swagger file is updated, put it in `pkg/cedar/intake/cedar_intake.json`, then run `scripts/generate_cedar_intake_client` to preprocess it and regenerate code. See [the intake folder's README](/pkg/cedar/intake/README.md) for more information.

### Connecting to CEDAR when running locally

Make sure the `cedarCoreEnabled` LaunchDarkly flag is set to true. If you're not connected to LaunchDarkly during local development, in [`pkg/cedar/core/client.go`](../pkg/cedar/core/client.go), set `cedarCoreEnabledDefault = true`.

`.envrc.local` will need to define environment variables for connecting to and authenticating with CEDAR. Add the following:

```
export CEDAR_API_URL="webmethods-apigw.cedarimpl.cms.gov"
export CEDAR_API_KEY=[insert API key from 1Password here]
```

Additionally, if you're using the `openconnect-tinyproxy` VPN container for selective proxying, add the following to your `.envrc.local` file to instruct Go to use the proxy:

```
export HTTP_PROXY=http://host.docker.internal:8888
export HTTPS_PROXY=http://host.docker.internal:8888
```
