"""
The current user's Launch Darkly key
"""
type LaunchDarklySettings {
  userKey: String!
  signedHash: String!
}

"""
The current user of the application
"""
type CurrentUser {
  launchDarkly: LaunchDarklySettings!
}

"""
ModelPlan represent the data point for plans about a model. It is the central data type in the application
"""
type ModelPlan {
  id: UUID!
  modelName: String!
  abbreviation: String
  archived: Boolean!
  createdBy: UUID!
  createdByUserAccount: UserAccount!
  createdDts: Time!
  modifiedBy: UUID
  modifiedByUserAccount: UserAccount
  modifiedDts: Time
  basics: PlanBasics!
  generalCharacteristics: PlanGeneralCharacteristics!
  participantsAndProviders: PlanParticipantsAndProviders!
  beneficiaries: PlanBeneficiaries!
  opsEvalAndLearning: PlanOpsEvalAndLearning!
  collaborators: [PlanCollaborator!]!
  documents: [PlanDocument!]!
  discussions: [PlanDiscussion!]!
  payments: PlanPayments!
  status: ModelStatus!
  isFavorite: Boolean!
  isCollaborator: Boolean!
  crTdls: [PlanCrTdl!]!
  prepareForClearance: PrepareForClearance!
  nameHistory(sort: SortDirection! = DESC): [String!]!
  operationalNeeds: [OperationalNeed!]!
  existingModelLinks: [ExistingModelLink!]!
}

type OperationalNeed {
    id: UUID!
    modelPlanID: UUID!

    needed: Boolean # if null, it has not been answered
    solutions(includeNotNeeded: Boolean! = false): [OperationalSolution!]!

    key: OperationalNeedKey
    name: String
    nameOther: String
    section: TaskListSection

    createdBy: UUID!
    createdByUserAccount: UserAccount!
    createdDts: Time!
    modifiedBy: UUID
    modifiedByUserAccount: UserAccount
    modifiedDts: Time
}

type PossibleOperationalNeed {
    id: Int!
    possibleSolutions: [PossibleOperationalSolution!]!
    name: String!
    key: OperationalNeedKey!
    section: TaskListSection

    createdBy: UUID!
    createdByUserAccount: UserAccount!
    createdDts: Time!
    modifiedBy: UUID
    modifiedByUserAccount: UserAccount
    modifiedDts: Time
}
type PossibleOperationalSolution {
    id: Int!
    name: String!
    key: OperationalSolutionKey!
    treatAsOther: Boolean!
    pointsOfContact: [PossibleOperationalSolutionContact!]!

    createdBy: UUID!
    createdByUserAccount: UserAccount!
    createdDts: Time!
    modifiedBy: UUID
    modifiedByUserAccount: UserAccount
    modifiedDts: Time
}

"""
PossibleOperationalSolutionContact represents a contact for a possible operational solution
"""
type PossibleOperationalSolutionContact {
  id: UUID!
  possibleOperationalSolutionID: Int!

  name: String!
  email: String!
  isTeam: Boolean!
  role: String


  createdBy: UUID!
  createdByUserAccount: UserAccount!
  createdDts: Time!
  modifiedBy: UUID
  modifiedByUserAccount: UserAccount
  modifiedDts: Time
}

"""
ModelPlanChanges represents the possible changes you can make to a model plan when updating it.
Fields explicitly set with NULL will be unset, and omitted fields will be left unchanged.
https://gqlgen.com/reference/changesets/
"""
input ModelPlanChanges @goModel(model: "map[string]interface{}") {
  modelName: String
  abbreviation: String
  someNumbers: [Int!]
  archived: Boolean
  status: ModelStatus
}

"""
PlanCollaborator represents a collaborator on a plan
"""
type PlanCollaborator {
  id: UUID!
  modelPlanID: UUID!
  userID: UUID!
  userAccount: UserAccount!
  teamRole: TeamRole!
  createdBy: UUID!
  createdByUserAccount: UserAccount!
  createdDts: Time!
  modifiedBy: UUID
  modifiedByUserAccount: UserAccount
  modifiedDts: Time
}
"""
ExistingModel represents a model that already exists outside of the scope of MINT
"""
type ExistingModel {
  id: Int
  modelName: String
  stage: String!
  numberOfParticipants: String
  category: String
  authority: String
  description: String
  numberOfBeneficiariesImpacted: Int
  numberOfPhysiciansImpacted: Int
  dateBegan: Time
  dateEnded: Time
  states: String
  keywords: String
  url: String
  displayModelSummary: Boolean

  createdBy: UUID!
  createdByUserAccount: UserAccount!
  createdDts: Time!
  modifiedBy: UUID
  modifiedByUserAccount: UserAccount
  modifiedDts: Time
}

type ExistingModelLink {
  id: UUID
  modelPlanID: UUID!
  existingModelID: Int
  existingModel: ExistingModel
  currentModelPlanID: UUID
  currentModelPlan: ModelPlan

  createdBy: UUID!
  createdByUserAccount: UserAccount!
  createdDts: Time!
  modifiedBy: UUID
  modifiedByUserAccount: UserAccount
  modifiedDts: Time
}

type TaskListSectionLockStatusChanged {
  changeType: ChangeType!
  lockStatus: TaskListSectionLockStatus!
  actionType: ActionType!
}

type TaskListSectionLockStatus {
  modelPlanID: UUID!
  section: TaskListSection!
  lockedByUserAccount: UserAccount!
  isAssessment: Boolean!
}

"""
PlanCollaboratorCreateInput represents the data required to create a collaborator on a plan
"""
input PlanCollaboratorCreateInput {
  modelPlanID: UUID!
  userName: String!
  teamRole: TeamRole!
}

"""
PlanDocument represents a document on a plan
"""
type PlanDocument {
  id: UUID!
  modelPlanID: UUID!

  """
  If isLink = true, then this is a URL to a linked document, not an uploaded document
  """
  isLink: Boolean!
  """
  URL is the link that must be provided if this is a link instead of an uploaded document
  """
  url: String



  fileType: String!
  bucket: String!
  fileKey: String!
  virusScanned: Boolean!
  virusClean: Boolean!
  restricted: Boolean!
  fileName: String!
  fileSize: Int!
  documentType: DocumentType!
  otherType: String
  optionalNotes: String
  downloadUrl: String
  deletedAt: Time
  numLinkedSolutions: Int!

  createdBy: UUID!
  createdByUserAccount: UserAccount!
  createdDts: Time!
  modifiedBy: UUID
  modifiedByUserAccount: UserAccount
  modifiedDts: Time
}


"""
PlanDocumentInput
"""
input PlanDocumentInput {
  modelPlanID: UUID!
  fileData: Upload!
  documentType: DocumentType!
  restricted: Boolean!
  otherTypeDescription: String
  optionalNotes: String
}

"""
PlanDocumentLinkInput
"""
input PlanDocumentLinkInput {
  modelPlanID: UUID!
  url: String!
  name: String!
  documentType: DocumentType!
  restricted: Boolean!
  otherTypeDescription: String
  optionalNotes: String
}

"""
Represents plan basics
"""
type PlanBasics {
  id: UUID!
  modelPlanID: UUID!

  demoCode: String
  amsModelID: String

  modelCategory: ModelCategory
  additionalModelCategories: [ModelCategory!]!
  cmsCenters: [CMSCenter!]!
  cmsOther: String
  cmmiGroups: [CMMIGroup!]!
  modelType: ModelType
  problem: String
  goal: String
  testInterventions: String
  note: String

  # Milestones
  completeICIP: Time
  clearanceStarts: Time
  clearanceEnds: Time
  announced: Time
  applicationsStart: Time
  applicationsEnd: Time
  performancePeriodStarts: Time
  performancePeriodEnds: Time
  wrapUpEnds: Time
  highLevelNote: String
  phasedIn: Boolean
  phasedInNote: String

  createdBy: UUID!
  createdByUserAccount: UserAccount!
  createdDts: Time!
  modifiedBy: UUID
  modifiedByUserAccount: UserAccount
  modifiedDts: Time

  readyForReviewBy: UUID
  readyForReviewByUserAccount: UserAccount
  readyForReviewDts: Time
  readyForClearanceBy: UUID
  readyForClearanceByUserAccount: UserAccount
  readyForClearanceDts: Time

  status: TaskStatus!
}

"""
PlanBasicsChanges represents the possible changes you can make to a Plan Basics object when updating it.
Fields explicitly set with NULL will be unset, and omitted fields will be left unchanged.
https://gqlgen.com/reference/changesets/
"""
input PlanBasicsChanges @goModel(model: "map[string]interface{}") {
  demoCode: String
  amsModelID: String

  modelCategory: ModelCategory
  additionalModelCategories: [ModelCategory!]
  cmsCenters: [CMSCenter!]
  cmsOther: String
  cmmiGroups: [CMMIGroup!]
  modelType: ModelType
  problem: String
  goal: String
  testInterventions: String
  note: String

  # Milestones
  completeICIP: Time
  clearanceStarts: Time
  clearanceEnds: Time
  announced: Time
  applicationsStart: Time
  applicationsEnd: Time
  performancePeriodStarts: Time
  performancePeriodEnds: Time
  wrapUpEnds: Time
  highLevelNote: String
  phasedIn: Boolean
  phasedInNote: String
  status: TaskStatusInput
}

"""
Represents a person response from the Okta API
"""
type UserInfo {
  firstName: String!
  lastName: String!
  displayName: String!
  email: String!
  username: String!
}

"""
PlanDiscussion represents plan discussion
"""
type PlanDiscussion  {
	id: UUID!
	modelPlanID: UUID!
	content: String
  userRole: DiscussionUserRole
  userRoleDescription: String
  replies: [DiscussionReply!]!
  isAssessment: Boolean!


  createdBy: UUID!
  createdByUserAccount: UserAccount!
  createdDts: Time!
  modifiedBy: UUID
  modifiedByUserAccount: UserAccount
  modifiedDts: Time
}

"""
PlanDiscussionCreateInput represents the necessary fields to create a plan discussion
"""
input PlanDiscussionCreateInput {
  modelPlanID: UUID!
  content: String!
  userRole: DiscussionUserRole
  userRoleDescription: String
}

"""
PlanDiscussionChanges represents the possible changes you can make to a plan discussion when updating it.
Fields explicitly set with NULL will be unset, and omitted fields will be left unchanged.
https://gqlgen.com/reference/changesets/
"""
input PlanDiscussionChanges @goModel(model: "map[string]interface{}") {
  content: String
  userRole: DiscussionUserRole
  userRoleDescription: String
}

"""
DiscussionReply represents a discussion reply
"""
type DiscussionReply  {
	id: UUID!
	discussionID: UUID!
	content: String
  userRole: DiscussionUserRole
  userRoleDescription: String
  isAssessment: Boolean!

  createdBy: UUID!
  createdByUserAccount: UserAccount!
  createdDts: Time!
  modifiedBy: UUID
  modifiedByUserAccount: UserAccount
  modifiedDts: Time
}

"""
DiscussionReplyCreateInput represents the necessary fields to create a discussion reply
"""
input DiscussionReplyCreateInput {
  discussionID: UUID!
  content: String!
  userRole: DiscussionUserRole
  userRoleDescription: String
}

"""
DiscussionReplyChanges represents the possible changes you can make to a discussion reply when updating it.
Fields explicitly set with NULL will be unset, and omitted fields will be left unchanged.
https://gqlgen.com/reference/changesets/
"""
input DiscussionReplyChanges @goModel(model: "map[string]interface{}") {
  content: String
  userRole: DiscussionUserRole
  userRoleDescription: String
}

"""
PlanGeneralCharacteristics represents a plan general characteristics object
"""
type PlanGeneralCharacteristics {
  id: UUID!
  modelPlanID: UUID!

  # Page 1
  isNewModel: Boolean
  existingModel: String
  resemblesExistingModel: Boolean
  resemblesExistingModelHow: String
  resemblesExistingModelNote: String
  hasComponentsOrTracks: Boolean
  hasComponentsOrTracksDiffer: String
  hasComponentsOrTracksNote: String

  # Page 2
  alternativePaymentModelTypes: [AlternativePaymentModelType!]!
  alternativePaymentModelNote: String
  keyCharacteristics: [KeyCharacteristic!]!
  keyCharacteristicsOther: String
  keyCharacteristicsNote: String
  collectPlanBids: Boolean
  collectPlanBidsNote: String
  managePartCDEnrollment: Boolean
  managePartCDEnrollmentNote: String
  planContractUpdated: Boolean
  planContractUpdatedNote: String

  # Page 3
  careCoordinationInvolved: Boolean
  careCoordinationInvolvedDescription: String
  careCoordinationInvolvedNote: String
  additionalServicesInvolved: Boolean
  additionalServicesInvolvedDescription: String
  additionalServicesInvolvedNote: String
  communityPartnersInvolved: Boolean
  communityPartnersInvolvedDescription: String
  communityPartnersInvolvedNote: String

  # Page 4
  geographiesTargeted: Boolean
  geographiesTargetedTypes: [GeographyType!]!
  geographiesTargetedTypesOther: String
  geographiesTargetedAppliedTo: [GeographyApplication!]!
  geographiesTargetedAppliedToOther: String
  geographiesTargetedNote: String
  participationOptions: Boolean
  participationOptionsNote: String
  agreementTypes: [AgreementType!]!
  agreementTypesOther: String
  multiplePatricipationAgreementsNeeded: Boolean
  multiplePatricipationAgreementsNeededNote: String

  # Page 5
  rulemakingRequired: Boolean
  rulemakingRequiredDescription: String
  rulemakingRequiredNote: String
  authorityAllowances: [AuthorityAllowance!]!
  authorityAllowancesOther: String
  authorityAllowancesNote: String
  waiversRequired: Boolean
  waiversRequiredTypes: [WaiverType!]!
  waiversRequiredNote: String

  createdBy: UUID!
  createdByUserAccount: UserAccount!
  createdDts: Time!
  modifiedBy: UUID
  modifiedByUserAccount: UserAccount
  modifiedDts: Time

  readyForReviewBy: UUID
  readyForReviewByUserAccount: UserAccount
  readyForReviewDts: Time
  readyForClearanceBy: UUID
  readyForClearanceByUserAccount: UserAccount
  readyForClearanceDts: Time

  status: TaskStatus!
}

"""
PlanGeneralCharacteristicsChanges represents the possible changes you can make to a
general characteristics object when updating it.
Fields explicitly set with NULL will be unset, and omitted fields will be left unchanged.
https://gqlgen.com/reference/changesets/
"""
input PlanGeneralCharacteristicsChanges @goModel(model: "map[string]interface{}") {
  # Page 1
  isNewModel: Boolean
  existingModel: String
  resemblesExistingModel: Boolean
  resemblesExistingModelHow: String
  resemblesExistingModelNote: String
  hasComponentsOrTracks: Boolean
  hasComponentsOrTracksDiffer: String
  hasComponentsOrTracksNote: String

  # Page 2
  alternativePaymentModelTypes: [AlternativePaymentModelType!]
  alternativePaymentModelNote: String
  keyCharacteristics: [KeyCharacteristic!]
  keyCharacteristicsOther: String
  keyCharacteristicsNote: String
  collectPlanBids: Boolean
  collectPlanBidsNote: String
  managePartCDEnrollment: Boolean
  managePartCDEnrollmentNote: String
  planContractUpdated: Boolean
  planContractUpdatedNote: String

  # Page 3
  careCoordinationInvolved: Boolean
  careCoordinationInvolvedDescription: String
  careCoordinationInvolvedNote: String
  additionalServicesInvolved: Boolean
  additionalServicesInvolvedDescription: String
  additionalServicesInvolvedNote: String
  communityPartnersInvolved: Boolean
  communityPartnersInvolvedDescription: String
  communityPartnersInvolvedNote: String

  # Page 4
  geographiesTargeted: Boolean
  geographiesTargetedTypes: [GeographyType!]
  geographiesTargetedTypesOther: String
  geographiesTargetedAppliedTo: [GeographyApplication!]
  geographiesTargetedAppliedToOther: String
  geographiesTargetedNote: String
  participationOptions: Boolean
  participationOptionsNote: String
  agreementTypes: [AgreementType!]
  agreementTypesOther: String
  multiplePatricipationAgreementsNeeded: Boolean
  multiplePatricipationAgreementsNeededNote: String

  # Page 5
  rulemakingRequired: Boolean
  rulemakingRequiredDescription: String
  rulemakingRequiredNote: String
  authorityAllowances: [AuthorityAllowance!]
  authorityAllowancesOther: String
  authorityAllowancesNote: String
  waiversRequired: Boolean
  waiversRequiredTypes: [WaiverType!]
  waiversRequiredNote: String

  status: TaskStatusInput
}

"""
Plan Beneficiaries represents the the beneficiaries section of the task list
"""

type PlanBeneficiaries {
  id: UUID!
  modelPlanID: UUID!
  #Page 1
  beneficiaries: [BeneficiariesType!]!
  beneficiariesOther: String
  beneficiariesNote: String
  treatDualElligibleDifferent: TriStateAnswer
  treatDualElligibleDifferentHow: String
  treatDualElligibleDifferentNote: String
  excludeCertainCharacteristics: TriStateAnswer
  excludeCertainCharacteristicsCriteria: String
  excludeCertainCharacteristicsNote: String
  #Page 2
  numberPeopleImpacted: Int
  estimateConfidence: ConfidenceType
  confidenceNote: String
  beneficiarySelectionMethod: [SelectionMethodType!]!
  beneficiarySelectionOther: String
  beneficiarySelectionNote: String
  #Page 3
  beneficiarySelectionFrequency: FrequencyType
  beneficiarySelectionFrequencyOther: String
  beneficiarySelectionFrequencyNote: String
  beneficiaryOverlap: OverlapType
  beneficiaryOverlapNote: String
  precedenceRules: String

  createdBy: UUID!
  createdByUserAccount: UserAccount!
  createdDts: Time!
  modifiedBy: UUID
  modifiedByUserAccount: UserAccount
  modifiedDts: Time

  readyForReviewBy: UUID
  readyForReviewByUserAccount: UserAccount
  readyForReviewDts: Time
  readyForClearanceBy: UUID
  readyForClearanceByUserAccount: UserAccount
  readyForClearanceDts: Time

  status: TaskStatus!
}

input PlanBeneficiariesChanges @goModel(model: "map[string]interface{}") {
  #Page 1
  beneficiaries: [BeneficiariesType!]
  beneficiariesOther: String
  beneficiariesNote: String
  treatDualElligibleDifferent: TriStateAnswer
  treatDualElligibleDifferentHow: String
  treatDualElligibleDifferentNote: String
  excludeCertainCharacteristics: TriStateAnswer
  excludeCertainCharacteristicsCriteria: String
  excludeCertainCharacteristicsNote: String
  #Page 2
  numberPeopleImpacted: Int
  estimateConfidence: ConfidenceType
  confidenceNote: String
  beneficiarySelectionMethod: [SelectionMethodType!]
  beneficiarySelectionOther: String
  beneficiarySelectionNote: String
  #Page 3
  beneficiarySelectionFrequency: FrequencyType
  beneficiarySelectionFrequencyOther: String
  beneficiarySelectionFrequencyNote: String
  beneficiaryOverlap: OverlapType
  beneficiaryOverlapNote: String
  precedenceRules: String

  status: TaskStatusInput
}

"""
PlanParticipantsAndProviders is the task list section that deals with information regarding all Providers and Participants
"""
type PlanParticipantsAndProviders {
  id: UUID!
  modelPlanID: UUID!

  #Page 1
  participants:                      [ParticipantsType!]!
  medicareProviderType:              String
  statesEngagement:                  String
  participantsOther:                 String
  participantsNote:                  String
  participantsCurrentlyInModels:     Boolean
  participantsCurrentlyInModelsNote: String
  modelApplicationLevel:             String

  #Page 2
  expectedNumberOfParticipants: Int
  estimateConfidence:           ConfidenceType
  confidenceNote:               String
  recruitmentMethod:            RecruitmentType
  recruitmentOther:             String
  recruitmentNote:              String
  selectionMethod:              [ParticipantSelectionType!]!
  selectionOther:               String
  selectionNote:                String

  #Page 3
  communicationMethod:   [ParticipantCommunicationType!]!
  communicationMethodOther:   String
  communicationNote:     String
  participantAssumeRisk: Boolean
  riskType:              ParticipantRiskType
  riskOther:             String
  riskNote:              String
  willRiskChange:        Boolean
  willRiskChangeNote:    String

  #Page 4
  coordinateWork:          Boolean
  coordinateWorkNote:      String
  gainsharePayments:       Boolean
  gainsharePaymentsTrack: Boolean
  gainsharePaymentsNote:   String
  participantsIds:         [ParticipantsIDType!]!
  participantsIdsOther:    String
  participantsIDSNote:     String

  #Page 5
  providerAdditionFrequency:      FrequencyType
  providerAdditionFrequencyOther: String
  providerAdditionFrequencyNote:  String
  providerAddMethod:              [ProviderAddType!]!
  providerAddMethodOther:         String
  providerAddMethodNote:          String
  providerLeaveMethod:            [ProviderLeaveType!]!
  providerLeaveMethodOther:       String
  providerLeaveMethodNote:        String
  providerOverlap:                OverlapType
  providerOverlapHierarchy:       String
  providerOverlapNote:            String


  createdBy: UUID!
  createdByUserAccount: UserAccount!
  createdDts: Time!
  modifiedBy: UUID
  modifiedByUserAccount: UserAccount
  modifiedDts: Time

  readyForReviewBy: UUID
  readyForReviewByUserAccount: UserAccount
  readyForReviewDts: Time
  readyForClearanceBy: UUID
  readyForClearanceByUserAccount: UserAccount
  readyForClearanceDts: Time

  status: TaskStatus!

}

"""
PlanParticipantsAndProvidersChanges represents the possible changes you can make to a
providers and participants object when updating it.
Fields explicitly set with NULL will be unset, and omitted fields will be left unchanged.
https://gqlgen.com/reference/changesets/
"""
input PlanParticipantsAndProvidersChanges @goModel(model: "map[string]interface{}") {
  #Page 1
  participants:                      [ParticipantsType!]
  medicareProviderType:              String
  statesEngagement:                  String
  participantsOther:                 String
  participantsNote:                  String
  participantsCurrentlyInModels:     Boolean
  participantsCurrentlyInModelsNote: String
  modelApplicationLevel:             String

  #Page 2
  expectedNumberOfParticipants: Int
  estimateConfidence:           ConfidenceType
  confidenceNote:               String
  recruitmentMethod:            RecruitmentType
  recruitmentOther:             String
  recruitmentNote:              String
  selectionMethod:              [ParticipantSelectionType!]
  selectionOther:               String
  selectionNote:                String

  #Page 3
  communicationMethod:   [ParticipantCommunicationType!]
  communicationMethodOther:   String
  communicationNote:     String
  participantAssumeRisk: Boolean
  riskType:              ParticipantRiskType
  riskOther:             String
  riskNote:              String
  willRiskChange:        Boolean
  willRiskChangeNote:    String

  #Page 4
  coordinateWork:          Boolean
  coordinateWorkNote:      String
  gainsharePayments:       Boolean
  gainsharePaymentsTrack: Boolean
  gainsharePaymentsNote:   String
  participantsIds:         [ParticipantsIDType!]
  participantsIdsOther:    String
  participantsIDSNote:     String

  #Page 5
  providerAdditionFrequency:      FrequencyType
  providerAdditionFrequencyOther: String
  providerAdditionFrequencyNote:  String
  providerAddMethod:              [ProviderAddType!]
  providerAddMethodOther:         String
  providerAddMethodNote:          String
  providerLeaveMethod:            [ProviderLeaveType!]
  providerLeaveMethodOther:       String
  providerLeaveMethodNote:        String
  providerOverlap:                OverlapType
  providerOverlapHierarchy:       String
  providerOverlapNote:            String

  status: TaskStatusInput
}

"""
PlanPayments is the task list section that deals with information regarding Payments
"""
type PlanPayments {
  id: UUID!
  modelPlanID: UUID!

  # Page 1
  fundingSource:                      [FundingSource!]!
  fundingSourceTrustFundType:         [TrustFundType!]!
  fundingSourceOther:                 String
  fundingSourceNote:                  String
  fundingSourceR:                     [FundingSource!]!
  fundingSourceRTrustFundType:        [TrustFundType!]!
  fundingSourceROther:                String
  fundingSourceRNote:                 String
  payRecipients:                      [PayRecipient!]!
  payRecipientsOtherSpecification:    String
  payRecipientsNote:                  String
  payType:                            [PayType!]!
  payTypeNote:                        String

  # Page 2
  payClaims:                                      [ClaimsBasedPayType!]!
  payClaimsOther:                                 String
  payClaimsNote:                                  String
  shouldAnyProvidersExcludedFFSSystems:           Boolean
  shouldAnyProviderExcludedFFSSystemsNote:        String
  changesMedicarePhysicianFeeSchedule:            Boolean
  changesMedicarePhysicianFeeScheduleNote:        String
  affectsMedicareSecondaryPayerClaims:            Boolean
  affectsMedicareSecondaryPayerClaimsHow:         String
  affectsMedicareSecondaryPayerClaimsNote:        String
  payModelDifferentiation:                        String

  # Page 3
  creatingDependenciesBetweenServices:     Boolean
  creatingDependenciesBetweenServicesNote: String
  needsClaimsDataCollection:               Boolean
  needsClaimsDataCollectionNote:           String
  providingThirdPartyFile:                 Boolean
  isContractorAwareTestDataRequirements:   Boolean

  # Page 4
  beneficiaryCostSharingLevelAndHandling:          String
  waiveBeneficiaryCostSharingForAnyServices:       Boolean
  waiveBeneficiaryCostSharingServiceSpecification: String
  waiverOnlyAppliesPartOfPayment:                  Boolean
  waiveBeneficiaryCostSharingNote:                 String

  # Page 5
  nonClaimsPayments:                               [NonClaimsBasedPayType!]!
  nonClaimsPaymentOther:                           String
  nonClaimsPaymentsNote:                           String
  paymentCalculationOwner:                         String
  numberPaymentsPerPayCycle:                       String
  numberPaymentsPerPayCycleNote:                   String
  sharedSystemsInvolvedAdditionalClaimPayment:     Boolean
  sharedSystemsInvolvedAdditionalClaimPaymentNote: String
  planningToUseInnovationPaymentContractor:        Boolean
  planningToUseInnovationPaymentContractorNote:    String

  # Page 6
  expectedCalculationComplexityLevel:                ComplexityCalculationLevelType
  expectedCalculationComplexityLevelNote:            String
  canParticipantsSelectBetweenPaymentMechanisms:     Boolean
  canParticipantsSelectBetweenPaymentMechanismsHow:  String
  canParticipantsSelectBetweenPaymentMechanismsNote: String
  anticipatedPaymentFrequency:                       [AnticipatedPaymentFrequencyType!]!
  anticipatedPaymentFrequencyOther:                  String
  anticipatedPaymentFrequencyNote:                   String

  # Page 7
  willRecoverPayments:                               Boolean
  willRecoverPaymentsNote:                           String
  anticipateReconcilingPaymentsRetrospectively:      Boolean
  anticipateReconcilingPaymentsRetrospectivelyNote:  String
  paymentStartDate:                                  Time
  paymentStartDateNote:                              String

  # Meta

  createdBy: UUID!
  createdByUserAccount: UserAccount!
  createdDts: Time!
  modifiedBy: UUID
  modifiedByUserAccount: UserAccount
  modifiedDts: Time

  readyForReviewBy: UUID
  readyForReviewByUserAccount: UserAccount
  readyForReviewDts: Time
  readyForClearanceBy: UUID
  readyForClearanceByUserAccount: UserAccount
  readyForClearanceDts: Time

  status:      TaskStatus!
}

input PlanPaymentsChanges @goModel(model: "map[string]interface{}") {
  # Page 1
  fundingSource:                      [FundingSource!]
  fundingSourceTrustFundType:         [TrustFundType!]
  fundingSourceOther:                 String
  fundingSourceNote:                  String
  fundingSourceR:                     [FundingSource!]
  fundingSourceRTrustFundType:        [TrustFundType!]
  fundingSourceROther:                String
  fundingSourceRNote:                 String
  payRecipients:                      [PayRecipient!]
  payRecipientsOtherSpecification:    String
  payRecipientsNote:                  String
  payType:                            [PayType!]
  payTypeNote:                        String

  # Page 2
  payClaims:                                      [ClaimsBasedPayType!]
  payClaimsOther:                                 String
  payClaimsNote:                                  String
  shouldAnyProvidersExcludedFFSSystems:           Boolean
  shouldAnyProviderExcludedFFSSystemsNote:        String
  changesMedicarePhysicianFeeSchedule:            Boolean
  changesMedicarePhysicianFeeScheduleNote:        String
  affectsMedicareSecondaryPayerClaims:            Boolean
  affectsMedicareSecondaryPayerClaimsHow:         String
  affectsMedicareSecondaryPayerClaimsNote:        String
  payModelDifferentiation:                        String

  # Page 3
  creatingDependenciesBetweenServices:     Boolean
  creatingDependenciesBetweenServicesNote: String
  needsClaimsDataCollection:               Boolean
  needsClaimsDataCollectionNote:           String
  providingThirdPartyFile:                 Boolean
  isContractorAwareTestDataRequirements:   Boolean

  # Page 4
  beneficiaryCostSharingLevelAndHandling:          String
  waiveBeneficiaryCostSharingForAnyServices:       Boolean
  waiveBeneficiaryCostSharingServiceSpecification: String
  waiverOnlyAppliesPartOfPayment:                  Boolean
  waiveBeneficiaryCostSharingNote:                 String

  # Page 5
  nonClaimsPayments:                               [NonClaimsBasedPayType!]
  nonClaimsPaymentOther:                           String
  nonClaimsPaymentsNote:                           String
  paymentCalculationOwner:                         String
  numberPaymentsPerPayCycle:                       String
  numberPaymentsPerPayCycleNote:                  String
  sharedSystemsInvolvedAdditionalClaimPayment:     Boolean
  sharedSystemsInvolvedAdditionalClaimPaymentNote: String
  planningToUseInnovationPaymentContractor:        Boolean
  planningToUseInnovationPaymentContractorNote:    String

  # Page 6
  expectedCalculationComplexityLevel:                       ComplexityCalculationLevelType
  expectedCalculationComplexityLevelNote:                   String
  canParticipantsSelectBetweenPaymentMechanisms:            Boolean
  canParticipantsSelectBetweenPaymentMechanismsHow:         String
  canParticipantsSelectBetweenPaymentMechanismsNote:        String
  anticipatedPaymentFrequency:                              [AnticipatedPaymentFrequencyType!]
  anticipatedPaymentFrequencyOther:                         String
  anticipatedPaymentFrequencyNote:                         String

  # Page 7
  willRecoverPayments:                               Boolean
  willRecoverPaymentsNote:                          String
  anticipateReconcilingPaymentsRetrospectively:      Boolean
  anticipateReconcilingPaymentsRetrospectivelyNote: String
  paymentStartDate:                                  Time
  paymentStartDateNote:                             String

  status: TaskStatusInput
}

"""
NDAInfo represents whether a user has agreed to an NDA or not. If agreed to previously, there will be a datestamp visible
"""
type NDAInfo {
  agreed: Boolean!
  agreedDts: Time
}

input ReportAProblemInput {
  isAnonymousSubmission: Boolean!
  allowContact: Boolean
  section: ReportAProblemSection
  sectionOther: String
  whatDoing: String
  whatWentWrong: String
  severity: ReportAProblemSeverity
  severityOther: String
}

type PlanFavorite {
    id: UUID!
    modelPlanID: UUID!
    userID: UUID!
    userAccount: UserAccount!

    createdBy: UUID!
    createdByUserAccount: UserAccount!
    createdDts: Time!
    modifiedBy: UUID
    modifiedByUserAccount: UserAccount
    modifiedDts: Time

}

type PlanCrTdl {
    id: UUID!
    modelPlanID: UUID!

    idNumber: String!
    dateInitiated: Time!
    title: String!
    note: String

    createdBy: UUID!
    createdByUserAccount: UserAccount!
    createdDts: Time!
    modifiedBy: UUID
    modifiedByUserAccount: UserAccount
    modifiedDts: Time
}

input PlanCrTdlCreateInput {
    modelPlanID: UUID!

    idNumber: String!
    dateInitiated: Time!
    title: String!
    note: String
}

input PlanCrTdlChanges @goModel(model: "map[string]interface{}") {
    idNumber: String
    dateInitiated: Time
    title: String
    note: String
}

type PrepareForClearance {
  status: PrepareForClearanceStatus!
  latestClearanceDts: Time
}

type AuditChange {
  id: Int!
  primaryKey: UUID!
  foreignKey: UUID
  tableName: String!
  action: String!
  fields: Map!
  modifiedBy: UUID
  modifiedByUserAccount: UserAccount
  modifiedDts: Time
}


type OperationalSolution {
    id: UUID!
    operationalNeedID: UUID!

    solutionType: Int
    needed: Boolean # if null, it has not been selectd
    name: String
    key: OperationalSolutionKey
    nameOther: String

    pocName: String
    pocEmail: String
    mustStartDts: Time
    mustFinishDts: Time
    isOther: Boolean!
    isCommonSolution: Boolean!
    otherHeader: String
    status: OpSolutionStatus!

    documents: [PlanDocument!]!
    operationalSolutionSubtasks: [OperationalSolutionSubtask!]!

    createdBy: UUID!
    createdByUserAccount: UserAccount!
    createdDts: Time!
    modifiedBy: UUID
    modifiedByUserAccount: UserAccount
    modifiedDts: Time
}

input OperationalSolutionChanges @goModel(model: "map[string]interface{}"){
    needed: Boolean
    nameOther: String # Only valid for when solution type is null

    pocName: String
    pocEmail: String
    mustStartDts: Time
    mustFinishDts: Time
    otherHeader: String
    status: OpSolutionStatus
}

type PlanDocumentSolutionLink {
id: UUID!
solutionID: UUID!
documentID: UUID!

createdBy: UUID!
createdByUserAccount: UserAccount!
createdDts: Time!
modifiedBy: UUID
modifiedByUserAccount: UserAccount
modifiedDts: Time
}

input CreateOperationalSolutionSubtaskInput {
  name: String!
  status: OperationalSolutionSubtaskStatus!
}

input UpdateOperationalSolutionSubtaskInput {
  id: UUID!
  changes: UpdateOperationalSolutionSubtaskChangesInput!
}

input UpdateOperationalSolutionSubtaskChangesInput @goModel(model: "map[string]interface{}") {
  name: String!
  status: OperationalSolutionSubtaskStatus!
}

type OperationalSolutionSubtask {
  id: UUID!
  solutionID: UUID!
  name: String!
  status: OperationalSolutionSubtaskStatus!

  createdBy: UUID!
  createdByUserAccount: UserAccount!
  createdDts: Time!
  modifiedBy: UUID
  modifiedByUserAccount: UserAccount
  modifiedDts: Time
}

type ChangedFields {
  changes: [Field!]!
}

type Field {
  name: String!
  nameCamelCase: String!
  value: FieldValue!
}

type FieldValue {
  new: Any
  old: Any
}

type ChangeTableRecord {
  guid: ID!
  modelPlanID: UUID!
  tableID: Int!

  """
  Returns the table name in the format of the type returned in GraphQL
  Example:  a table name of model_plan returns as ModelPlan
  """
  gqlTableName: GQLTableName!
  tableName: String!
  primaryKey: UUID!
  foreignKey: UUID
  action: String!
  fields: ChangedFields!
  modifiedDts: Time
  modifiedBy: UserAccount
}

# lint-disable enum-values-all-caps
enum GQLTableName {
  analyzedAudit
  discussionReply
  existingModel
  existingModelLink
  modelPlan
  ndaAgreement
  operationalNeed
  operationalSolution
  operationalSolutionSubtask
  planBasics
  planBeneficiaries
  planCollaborator
  planCrTdl
  planDiscussion
  planDocument
  planDocumentSolutionLink
  planGeneralCharacteristics
  planOpsEvalAndLearning
  planParticipantsAndProviders
  planPayments
  possibleOperationalNeed
  possibleOperationalSolution
  userAccount
}
# lint-enable enum-values-all-caps


type DateHistogramAggregationBucket {
  key: String!
  docCount: Int!
  maxModifiedDts: Time!
  minModifiedDts: Time!
}

input SearchFilter {
  type: SearchFilterType!
  value: Any!
}

input ChangeHistorySortParams {
  field: ChangeHistorySortKey!
  order: SortDirection!
}

input PageParams {
  offset: Int!
  limit: Int!
}

type DiscussionRoleSelection {
  userRole: DiscussionUserRole!
  userRoleDescription: String
}
"""
The inputs to the user feedback form
"""
input SendFeedbackEmailInput {
  isAnonymousSubmission: Boolean!
  allowContact: Boolean
  cmsRole: String
  mintUsedFor: [MintUses!]
  mintUsedForOther: String
  systemEasyToUse: EaseOfUse
  systemEasyToUseOther: String
  howSatisfied: SatisfactionLevel
  howCanWeImprove: String
}

"""
Query definition for the schema
"""
type Query {
  currentUser: CurrentUser!
  modelPlan(id: UUID!): ModelPlan!
  @hasAnyRole(roles: [MINT_USER, MINT_MAC])
  planDocument(id: UUID!): PlanDocument!
  @hasAnyRole(roles: [MINT_USER, MINT_MAC])
  modelPlanCollection(filter: ModelPlanFilter! = COLLAB_ONLY): [ModelPlan!]!
  @hasAnyRole(roles: [MINT_USER, MINT_MAC])
  existingModelCollection: [ExistingModel!]!
  @hasAnyRole(roles: [MINT_USER, MINT_MAC])
  searchOktaUsers(searchTerm: String!): [UserInfo!]!
  @hasAnyRole(roles: [MINT_USER, MINT_MAC])
  planCollaboratorByID(id: UUID!): PlanCollaborator!
  @hasAnyRole(roles: [MINT_USER, MINT_MAC])
  taskListSectionLocks(modelPlanID: UUID!): [TaskListSectionLockStatus!]!
  @hasAnyRole(roles: [MINT_USER, MINT_MAC])
  planPayments(id: UUID!): PlanPayments!
  @hasAnyRole(roles: [MINT_USER, MINT_MAC])
  ndaInfo: NDAInfo!
  @hasAnyRole(roles: [MINT_USER, MINT_MAC])
  crTdl(id: UUID!): PlanCrTdl!
  @hasAnyRole(roles: [MINT_USER, MINT_MAC])
  operationalSolutions(operationalNeedID: UUID!, includeNotNeeded: Boolean! = false): [OperationalSolution!]!
  @hasAnyRole(roles: [MINT_USER, MINT_MAC])
  operationalSolution(id: UUID!): OperationalSolution!
  @hasAnyRole(roles: [MINT_USER, MINT_MAC])
  operationalNeed(id: UUID!): OperationalNeed!
  @hasAnyRole(roles: [MINT_USER, MINT_MAC])
  auditChanges(tableName: String!, primaryKey: UUID!): [AuditChange!]!
  @hasAnyRole(roles: [MINT_USER, MINT_MAC])
  possibleOperationalNeeds: [PossibleOperationalNeed!]!
  @hasAnyRole(roles: [MINT_USER, MINT_MAC])
  possibleOperationalSolutions: [PossibleOperationalSolution!]!
  @hasAnyRole(roles: [MINT_USER, MINT_MAC])
  userAccount(username: String!): UserAccount!
  @hasAnyRole(roles: [MINT_USER, MINT_MAC])
  existingModelLink(id: UUID!): ExistingModelLink!
  @hasAnyRole(roles:[MINT_USER, MINT_MAC])
  searchChanges(filters: [SearchFilter!], sortBy: ChangeHistorySortParams, page: PageParams): [ChangeTableRecord!]!
  @hasAnyRole(roles: [MINT_USER, MINT_MAC])
  searchChangeTableDateHistogramConsolidatedAggregations(interval: String!, limit: Int!, offset: Int!): [DateHistogramAggregationBucket!]!
  @hasAnyRole(roles: [MINT_USER, MINT_MAC])
  mostRecentDiscussionRoleSelection: DiscussionRoleSelection
  @hasAnyRole(roles: [MINT_USER, MINT_MAC])
}

"""
Mutations definition for the schema
"""
type Mutation {
createModelPlan(modelName: String!): ModelPlan!
@hasRole(role: MINT_USER)

updateModelPlan(id: UUID!, changes: ModelPlanChanges!): ModelPlan!
@hasRole(role: MINT_USER)

createPlanCollaborator(input: PlanCollaboratorCreateInput!): PlanCollaborator!
@hasRole(role: MINT_USER)

updatePlanCollaborator(id: UUID!, newRole: TeamRole!): PlanCollaborator!
@hasRole(role: MINT_USER)

deletePlanCollaborator(id: UUID!): PlanCollaborator!
@hasRole(role: MINT_USER)

updatePlanBasics(id: UUID!, changes: PlanBasicsChanges!): PlanBasics!
@hasRole(role: MINT_USER)

updatePlanGeneralCharacteristics(id: UUID!, changes: PlanGeneralCharacteristicsChanges!): PlanGeneralCharacteristics!
@hasRole(role: MINT_USER)

updatePlanBeneficiaries(id: UUID!, changes: PlanBeneficiariesChanges!): PlanBeneficiaries!
@hasRole(role: MINT_USER)

updatePlanParticipantsAndProviders(id: UUID!, changes: PlanParticipantsAndProvidersChanges!): PlanParticipantsAndProviders!
@hasRole(role: MINT_USER)

updatePlanOpsEvalAndLearning(id: UUID!, changes: PlanOpsEvalAndLearningChanges!): PlanOpsEvalAndLearning!
@hasRole(role: MINT_USER)

uploadNewPlanDocument(input: PlanDocumentInput!): PlanDocument!
@hasRole(role: MINT_USER)

linkNewPlanDocument(input: PlanDocumentLinkInput!): PlanDocument!
@hasRole(role: MINT_USER)

deletePlanDocument(id: UUID!): Int!
@hasRole(role: MINT_USER)

createPlanDiscussion(input: PlanDiscussionCreateInput!): PlanDiscussion!
@hasAnyRole(roles: [MINT_USER, MINT_MAC])

updatePlanDiscussion(id: UUID!, changes: PlanDiscussionChanges!): PlanDiscussion!
@hasAnyRole(roles: [MINT_USER, MINT_MAC])

deletePlanDiscussion(id: UUID!): PlanDiscussion!
@hasRole(role: MINT_USER)

createDiscussionReply(input: DiscussionReplyCreateInput!): DiscussionReply!
@hasAnyRole(roles: [MINT_USER, MINT_MAC])

updateDiscussionReply(id: UUID!, changes: DiscussionReplyChanges!): DiscussionReply!
@hasAnyRole(roles: [MINT_USER, MINT_MAC])

deleteDiscussionReply(id: UUID!): DiscussionReply!
@hasRole(role: MINT_USER)

lockTaskListSection(modelPlanID: UUID!, section: TaskListSection!): Boolean!
@hasRole(role: MINT_USER)

unlockTaskListSection(modelPlanID: UUID!, section: TaskListSection!): Boolean!
@hasRole(role: MINT_USER)

unlockAllTaskListSections(modelPlanID: UUID!): [TaskListSectionLockStatus!]!
@hasRole(role: MINT_ASSESSMENT)

updatePlanPayments(id: UUID!, changes: PlanPaymentsChanges!): PlanPayments!
@hasRole(role: MINT_USER)

agreeToNDA(agree: Boolean! = true): NDAInfo!
@hasAnyRole(roles: [MINT_USER, MINT_MAC])

addPlanFavorite(modelPlanID: UUID!): PlanFavorite!
@hasAnyRole(roles: [MINT_USER, MINT_MAC])

deletePlanFavorite(modelPlanID: UUID!): PlanFavorite!
@hasAnyRole(roles: [MINT_USER, MINT_MAC])

createPlanCrTdl(input: PlanCrTdlCreateInput!): PlanCrTdl!
@hasRole(role: MINT_USER)

updatePlanCrTdl(id: UUID!, changes: PlanCrTdlChanges!): PlanCrTdl!
@hasRole(role: MINT_USER)

deletePlanCrTdl(id: UUID!): PlanCrTdl!
@hasRole(role: MINT_USER)

addOrUpdateCustomOperationalNeed(modelPlanID: UUID!, customNeedType: String! needed: Boolean!): OperationalNeed!
@hasRole(role: MINT_USER)

updateCustomOperationalNeedByID(id: UUID!, customNeedType: String needed: Boolean!): OperationalNeed!
@hasRole(role: MINT_USER)

createOperationalSolution(operationalNeedID: UUID!, solutionType: OperationalSolutionKey, changes: OperationalSolutionChanges!): OperationalSolution!
@hasRole(role: MINT_USER)

updateOperationalSolution(id: UUID!, changes: OperationalSolutionChanges!): OperationalSolution!
@hasRole(role: MINT_USER)

createPlanDocumentSolutionLinks(solutionID: UUID!, documentIDs: [UUID!]!): [PlanDocumentSolutionLink!]
@hasRole(role: MINT_USER)

removePlanDocumentSolutionLinks(solutionID: UUID!, documentIDs: [UUID!]!): Boolean!
@hasRole(role: MINT_USER)

createOperationalSolutionSubtasks(solutionID: UUID!, inputs: [CreateOperationalSolutionSubtaskInput!]!): [OperationalSolutionSubtask!]
@hasRole(role: MINT_USER)

updateOperationalSolutionSubtasks(inputs: [UpdateOperationalSolutionSubtaskInput!]!): [OperationalSolutionSubtask!]
@hasRole(role: MINT_USER)

deleteOperationalSolutionSubtask(id: UUID!): Int!
@hasRole(role: MINT_USER)

updateExistingModelLinks(modelPlanID: UUID!, existingModelIDs: [Int!],currentModelPlanIDs: [UUID!]): [ExistingModelLink!]!
@hasRole(role: MINT_USER)

shareModelPlan(modelPlanID: UUID!, viewFilter: ModelViewFilter, usernames: [String!]!, optionalMessage: String): Boolean!
@hasRole(role: MINT_USER)

reportAProblem(input: ReportAProblemInput!): Boolean!
@hasAnyRole(roles: [MINT_USER, MINT_MAC])
"""
This mutation sends feedback about the MINT product to the MINT team
"""
sendFeedbackEmail(input: SendFeedbackEmailInput!): Boolean!
}

type Subscription {
  onTaskListSectionLocksChanged(modelPlanID: UUID!): TaskListSectionLockStatusChanged!
  @hasRole(role: MINT_USER)

  onLockTaskListSectionContext(modelPlanID: UUID!): TaskListSectionLockStatusChanged!
  @hasRole(role: MINT_USER)
}

directive @hasRole(role: Role!) on FIELD_DEFINITION

directive @hasAnyRole(roles: [Role!]!) on FIELD_DEFINITION

# https://gqlgen.com/config/#inline-config-with-directives
directive @goModel(
  model: String
  models: [String!]
) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION

type UserAccount {
	id: UUID!
	username: String!
	isEUAID: Boolean
	commonName: String!
	locale: String!
	email: String!
	givenName: String!
	familyName: String!
	zoneInfo: String!
	hasLoggedIn: Boolean
}
