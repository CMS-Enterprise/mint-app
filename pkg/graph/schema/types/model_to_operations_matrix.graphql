type ModelsToOperationMatrix {
  milestones: [Milestone!]!
}

type Milestone {
  id: UUID!
  category: Category
  isCustom: Boolean! # Or maybe just a nullable "CommonMilestoneKey" to represent the same?
  name: String!
  description: String!
}

type Category {
  id: UUID!
  name: String!
  subCategory: Category
}

type CommonMilestone {
  id: UUID!
  key: CommonMilestoneKey! # Similar to OperationalSolutionKey, enum of possible common milestones
  name: String!
}


# input ModelPlanChanges @goModel(model: "map[string]interface{}") {
#   modelName: String
#   abbreviation: String
#   someNumbers: [Int!]
#   archived: Boolean
#   status: ModelStatus
# }

# extend type Query {
#   modelPlan(id: UUID!): ModelPlan!
#   @hasAnyRole(roles: [MINT_USER, MINT_MAC])

#   modelPlanCollection(filter: ModelPlanFilter! = COLLAB_ONLY): [ModelPlan!]!
#   @hasAnyRole(roles: [MINT_USER, MINT_MAC])
# }

# extend type Mutation {
#   createModelPlan(modelName: String!): ModelPlan!
#   @hasRole(role: MINT_USER)

#   updateModelPlan(id: UUID!, changes: ModelPlanChanges!): ModelPlan!
#   @hasRole(role: MINT_USER)

#   shareModelPlan(modelPlanID: UUID!, viewFilter: ModelViewFilter, usernames: [String!]!, optionalMessage: String): Boolean!
#   @hasRole(role: MINT_USER)
# }