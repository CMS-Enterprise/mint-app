type ModelsToOperationMatrix { # Added 1:1 on `type ModelPlan`
  categories: [Category!]! # Categories is at the top level because you _can_ have empty categories
  commonMilestones: [CommonMilestone!]!
  solutions: [Solution!]!
}

# Milestone represents a Milestone that has been added to a Model Plan's MTO
type Milestone {
  id: UUID!
  addedFromMilestoneLibrary: Boolean!
  name: String!
  description: String!
  solutions: [Solution!]!
}

# Solution represents a Solution that has been added to a Model Plan's MTO
type Solution {
  id: UUID!
  relatedMilestones: [Milestone!]!
  addedFromMilestoneLibrary: Boolean!
  name: String!
  description: String!
  solutions: [Solution!]!
}

# CommonMilestone represents a Milestone from the "Common Milestones" library
# It should not be used in contexts where a milestone has been added to a Model Plan (at that point, it'll be a "Milestone", not a "CommonMilestone")
type CommonMilestone {
  id: UUID! # TODO Is this really needed? It might be kind of confusing to reference `id` like this
  key: CommonMilestoneKey! # Similar to OperationalSolutionKey, enum of possible common milestones
  name: String!
  isAdded: Boolean! # To represent if this Common Milestone is _already_ part of the Model Plan's MTO
  isSuggested: Boolean!
  commonSolutions: [CommonSolution!]!
}

type CommonSolution {
  id: UUID! # TODO Is this really needed? It might be kind of confusing to reference `id` like this
  key: CommonSolutionKey! # Similar to OperationalSolutionKey, enum of possible common milestones
  name: String!
  isAdded: Boolean! # To represent if this Common Solution is _already_ added of the Model Plan's MTO
  isSuggested: Boolean!
}

enum CommonMilestoneKey {
  MILESTONE_A
  MILESTONE_B
}

enum CommonSolutionKey {
  SOLUTION_ONE
  SOLUTION_TWO
}

type Category {
  id: UUID!
  name: String!
  milestones: [Milestone!]!
  subCategories: [Category!]!
}

# input ModelPlanChanges @goModel(model: "map[string]interface{}") {
#   modelName: String
#   abbreviation: String
#   someNumbers: [Int!]
#   archived: Boolean
#   status: ModelStatus
# }

# extend type Query {
#   modelPlan(id: UUID!): ModelPlan!
#   @hasAnyRole(roles: [MINT_USER, MINT_MAC])

#   modelPlanCollection(filter: ModelPlanFilter! = COLLAB_ONLY): [ModelPlan!]!
#   @hasAnyRole(roles: [MINT_USER, MINT_MAC])
# }

# extend type Mutation {
#   createModelPlan(modelName: String!): ModelPlan!
#   @hasRole(role: MINT_USER)

#   updateModelPlan(id: UUID!, changes: ModelPlanChanges!): ModelPlan!
#   @hasRole(role: MINT_USER)

#   shareModelPlan(modelPlanID: UUID!, viewFilter: ModelViewFilter, usernames: [String!]!, optionalMessage: String): Boolean!
#   @hasRole(role: MINT_USER)
# }