package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen

import (
	"context"

	"github.com/google/uuid"

	"github.com/cms-enterprise/mint-app/pkg/appcontext"
	"github.com/cms-enterprise/mint-app/pkg/graph/generated"
	"github.com/cms-enterprise/mint-app/pkg/graph/model"
	"github.com/cms-enterprise/mint-app/pkg/models"
)

// UpdatePlanTimeline is the resolver for the updatePlanTimeline field.
func (r *mutationResolver) UpdatePlanTimeline(ctx context.Context, id uuid.UUID, changes map[string]interface{}) (*models.PlanTimeline, error) {
	principal := appcontext.Principal(ctx)
	logger := appcontext.ZLogger(ctx)

	return UpdatePlanTimeline(
		ctx,
		logger,
		id,
		changes,
		principal,
		r.store,
		r.emailService,
		r.emailTemplateService,
		r.addressBook,
	)
}

// UpcomingTimelineDate is the resolver for the upcomingTimelineDate field.
func (r *planTimelineResolver) UpcomingTimelineDate(ctx context.Context, obj *models.PlanTimeline) (*model.UpcomingTimelineDate, error) {
	upcoming, err := ModelPlanUpcomingPlanTimelineDate(ctx, obj.ModelPlanID)
	if err != nil {
		return nil, err
	}
	if upcoming == nil {
		return nil, nil
	}
	// Map fields from *UpcomingTimelineDate to *model.UpcomingTimelineDate as needed
	return &model.UpcomingTimelineDate{
		Date:      upcoming.Date,
		DateField: &upcoming.DateField,
	}, nil
}

// DatesAdded is the resolver for the datesAdded field.
func (r *planTimelineResolver) DatesAdded(ctx context.Context, obj *models.PlanTimeline) (int, error) {
	count := countPopulatedPlanTimelineDates(obj)
	return count, nil
}

// PlanTimeline returns generated.PlanTimelineResolver implementation.
func (r *Resolver) PlanTimeline() generated.PlanTimelineResolver { return &planTimelineResolver{r} }

type planTimelineResolver struct{ *Resolver }
