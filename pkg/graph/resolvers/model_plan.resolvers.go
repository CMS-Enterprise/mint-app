package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen

import (
	"context"
	"time"

	"github.com/google/uuid"

	"github.com/cms-enterprise/mint-app/pkg/appcontext"
	"github.com/cms-enterprise/mint-app/pkg/constants"
	"github.com/cms-enterprise/mint-app/pkg/flags"
	"github.com/cms-enterprise/mint-app/pkg/graph/generated"
	"github.com/cms-enterprise/mint-app/pkg/graph/model"
	"github.com/cms-enterprise/mint-app/pkg/models"
	"github.com/cms-enterprise/mint-app/pkg/userhelpers"
)

// Basics is the resolver for the basics field.
func (r *modelPlanResolver) Basics(ctx context.Context, obj *models.ModelPlan) (*models.PlanBasics, error) {
	return PlanBasicsGetByModelPlanIDLOADER(ctx, obj.ID)
}

// GeneralCharacteristics is the resolver for the generalCharacteristics field.
func (r *modelPlanResolver) GeneralCharacteristics(ctx context.Context, obj *models.ModelPlan) (*models.PlanGeneralCharacteristics, error) {
	return PlanGeneralCharacteristicsGetByModelPlanIDLOADER(ctx, obj.ID)
}

// ParticipantsAndProviders is the resolver for the participantsAndProviders field.
func (r *modelPlanResolver) ParticipantsAndProviders(ctx context.Context, obj *models.ModelPlan) (*models.PlanParticipantsAndProviders, error) {
	return PlanParticipantsAndProvidersGetByModelPlanIDLOADER(ctx, obj.ID)
}

// Beneficiaries is the resolver for the beneficiaries field.
func (r *modelPlanResolver) Beneficiaries(ctx context.Context, obj *models.ModelPlan) (*models.PlanBeneficiaries, error) {
	return PlanBeneficiariesGetByModelPlanIDLOADER(ctx, obj.ID)
}

// OpsEvalAndLearning is the resolver for the opsEvalAndLearning field.
func (r *modelPlanResolver) OpsEvalAndLearning(ctx context.Context, obj *models.ModelPlan) (*models.PlanOpsEvalAndLearning, error) {
	return PlanOpsEvalAndLearningGetByModelPlanIDLOADER(ctx, obj.ID)
}

// Collaborators is the resolver for the collaborators field.
func (r *modelPlanResolver) Collaborators(ctx context.Context, obj *models.ModelPlan) ([]*models.PlanCollaborator, error) {
	return PlanCollaboratorGetByModelPlanIDLOADER(ctx, obj.ID)
}

// Documents is the resolver for the documents field.
func (r *modelPlanResolver) Documents(ctx context.Context, obj *models.ModelPlan) ([]*models.PlanDocument, error) {
	logger := appcontext.ZLogger(ctx)
	principal := appcontext.Principal(ctx)

	documents, err := PlanDocumentsReadByModelPlanID(logger, obj.ID, principal, r.store, r.fileUploadS3Client)
	return documents, err
}

// Discussions is the resolver for the discussions field.
func (r *modelPlanResolver) Discussions(ctx context.Context, obj *models.ModelPlan) ([]*models.PlanDiscussion, error) {
	return PlanDiscussionGetByModelPlanIDLOADER(ctx, obj.ID)
}

// Payments is the resolver for the payments field.
func (r *modelPlanResolver) Payments(ctx context.Context, obj *models.ModelPlan) (*models.PlanPayments, error) {
	return PlanPaymentsGetByModelPlanIDLOADER(ctx, obj.ID)
}

// TaskListStatus is the resolver for the taskListStatus field.
func (r *modelPlanResolver) TaskListStatus(ctx context.Context, obj *models.ModelPlan) (models.TaskStatus, error) {
	logger := appcontext.ZLogger(ctx)
	return ModelPlanGetTaskListStatus(logger, obj.ID, r.store)
}

// SuggestedPhase is the resolver for the suggestedPhase field.
func (r *modelPlanResolver) SuggestedPhase(ctx context.Context, obj *models.ModelPlan) (*model.PhaseSuggestion, error) {
	return ModelPlanAnticipatedPhase(ctx, obj.Status, obj.ID)
}

// IsFavorite is the resolver for the isFavorite field.
func (r *modelPlanResolver) IsFavorite(ctx context.Context, obj *models.ModelPlan) (bool, error) {
	// TODO: should this be a data loader?
	principal := appcontext.Principal(ctx)
	logger := appcontext.ZLogger(ctx)

	return IsPlanFavorited(logger, principal, r.store, obj.ID)
}

// IsCollaborator is the resolver for the isCollaborator field.
func (r *modelPlanResolver) IsCollaborator(ctx context.Context, obj *models.ModelPlan) (bool, error) {
	principal := appcontext.Principal(ctx)
	logger := appcontext.ZLogger(ctx)

	return IsPlanCollaborator(logger, principal, r.store, obj.ID)
}

// Crs is the resolver for the crs field.
func (r *modelPlanResolver) Crs(ctx context.Context, obj *models.ModelPlan) ([]*models.PlanCR, error) {
	logger := appcontext.ZLogger(ctx)
	return PlanCRsGetByModelPlanID(logger, obj.ID, r.store)
}

// Tdls is the resolver for the tdls field.
func (r *modelPlanResolver) Tdls(ctx context.Context, obj *models.ModelPlan) ([]*models.PlanTDL, error) {
	logger := appcontext.ZLogger(ctx)
	return PlanTDLsGetByModelPlanID(logger, obj.ID, r.store)
}

// EchimpCRsAndTDLs is the resolver for the echimpCRsAndTDLs field.
func (r *modelPlanResolver) EchimpCRsAndTDLs(ctx context.Context, obj *models.ModelPlan) ([]models.EChimpCRAndTDLS, error) {
	// TODO Update to use flag value to conditionally use SQL/DB calls instead of S3 ECHIMP Cache
	principal := appcontext.Principal(ctx)
	logger := appcontext.ZLogger(ctx)

	// Get flag value for if ECHIMP is enabled or disabled
	echimpEnabled, err := flags.GetBool(r.ldClient, principal, flags.LDEChimpEnabledKey, false)
	if err != nil {
		return nil, err
	}

	// If ECHIMP integration is enabled, fetch CRs and TDLs by model plan ID from S3 (ECHIMP)
	if echimpEnabled {
		return GetEchimpCRAndTdlsByModelPlanID(r.echimpS3Client, r.viperConfig, logger, obj.ID)
	}

	// else (ECHIMP is disabled) fetch from our Database (but return the ECHIMP type)
	// TODO: Make resolver for CRs and TDLs by SQL --> shape as models.EChimpCRAndTDLs
	// Fetch CRs and TDLs from DB
	crsFromDB, err := PlanCRsGetByModelPlanID(logger, obj.ID, r.store)
	if err != nil {
		return nil, err
	}
	tdlsFromDB, err := PlanTDLsGetByModelPlanID(logger, obj.ID, r.store)
	if err != nil {
		return nil, err
	}

	// "Re-shape" from DB model into models.EChimpCRAndTDLS
	ret := []models.EChimpCRAndTDLS
	for _, cr := range crsFromDB {
		acct, err := cr.CreatedByUserAccount()
		crToAppend := models.EChimpCR{
			CrNumber:            cr.IDNumber,
			VersionNum:          "0", // no local equivalent
			Initiator:           "N/A",
			FirstName:           "",
			LastName:            "",
			Title:               "",
			SensitiveFlag:       "",
			ImplementationDate:  "",
			CrSummary:           "",
			CrStatus:            "",
			EmergencyCrFlag:     "",
			RelatedCrNumbers:    "",
			RelatedCrTdlNumbers: "",
			AssociatedModelUids: "",
		}
	}

	return nil, nil

}

// PrepareForClearance is the resolver for the prepareForClearance field.
func (r *modelPlanResolver) PrepareForClearance(ctx context.Context, obj *models.ModelPlan) (*model.PrepareForClearance, error) {
	logger := appcontext.ZLogger(ctx)
	return ReadyForClearanceRead(logger, r.store, obj.ID)
}

// NameHistory is the resolver for the nameHistory field.
func (r *modelPlanResolver) NameHistory(ctx context.Context, obj *models.ModelPlan, sort models.SortDirection) ([]string, error) {
	logger := appcontext.ZLogger(ctx)

	return ModelPlanNameHistory(logger, obj.ID, sort, r.store)
}

// OperationalNeeds is the resolver for the operationalNeeds field.
func (r *modelPlanResolver) OperationalNeeds(ctx context.Context, obj *models.ModelPlan) ([]*models.OperationalNeed, error) {
	return OperationalNeedCollectionGetByModelPlanIDLOADER(ctx, obj.ID)
}

// OpSolutionLastModifiedDts is the resolver for the opSolutionLastModifiedDts field.
func (r *modelPlanResolver) OpSolutionLastModifiedDts(ctx context.Context, obj *models.ModelPlan) (*time.Time, error) {
	return ModelPlanOpSolutionLastModifiedDtsGetByIDLOADER(ctx, obj.ID)
}

// CreateModelPlan is the resolver for the createModelPlan field.
func (r *mutationResolver) CreateModelPlan(ctx context.Context, modelName string) (*models.ModelPlan, error) {
	logger := appcontext.ZLogger(ctx)
	principal := appcontext.Principal(ctx)

	return ModelPlanCreate(
		ctx,
		logger,
		r.emailService,
		r.emailTemplateService,
		r.addressBook,
		modelName,
		nil,
		r.store,
		principal,
		userhelpers.GetUserInfoAccountInfoWrapperFunc(r.service.FetchUserInfo),
	)
}

// UpdateModelPlan is the resolver for the updateModelPlan field.
func (r *mutationResolver) UpdateModelPlan(ctx context.Context, id uuid.UUID, changes map[string]interface{}) (*models.ModelPlan, error) {
	principal := appcontext.Principal(ctx)
	logger := appcontext.ZLogger(ctx)

	return ModelPlanUpdate(logger, id, changes, principal, r.store)
}

// ShareModelPlan is the resolver for the shareModelPlan field.
func (r *mutationResolver) ShareModelPlan(ctx context.Context, modelPlanID uuid.UUID, viewFilter *models.ModelViewFilter, usernames []string, optionalMessage *string) (bool, error) {
	logger := appcontext.ZLogger(ctx)
	principal := appcontext.Principal(ctx)

	return ModelPlanShare(
		ctx,
		logger,
		r.store,
		principal,
		r.emailService,
		r.emailTemplateService,
		r.addressBook,
		modelPlanID,
		viewFilter,
		usernames,
		optionalMessage,
		userhelpers.GetUserInfoAccountInfoWrapperFunc(r.service.FetchUserInfo),
	)
}

// ModelPlan is the resolver for the modelPlan field.
func (r *queryResolver) ModelPlan(ctx context.Context, id uuid.UUID) (*models.ModelPlan, error) {
	logger := appcontext.ZLogger(ctx)
	constants.GetSampleUUID()

	if id == constants.GetSampleUUID() {
		return ModelPlanGetSampleModel(logger, r.store)
	}

	return ModelPlanGetByID(logger, id, r.store)
}

// ModelPlanCollection is the resolver for the modelPlanCollection field.
func (r *queryResolver) ModelPlanCollection(ctx context.Context, filter model.ModelPlanFilter) ([]*models.ModelPlan, error) {
	// TODO Update to use flag value to conditionally use SQL/DB calls instead of S3 ECHIMP Cache
	principal := appcontext.Principal(ctx)
	logger := appcontext.ZLogger(ctx)
	return ModelPlanCollection(r.echimpS3Client, r.viperConfig, logger, principal, r.store, filter)
}

// ModelPlan returns generated.ModelPlanResolver implementation.
func (r *Resolver) ModelPlan() generated.ModelPlanResolver { return &modelPlanResolver{r} }

type modelPlanResolver struct{ *Resolver }
