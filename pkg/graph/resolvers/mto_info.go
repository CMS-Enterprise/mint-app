package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen

import (
	"context"

	"github.com/google/uuid"
	"go.uber.org/zap"

	"github.com/cms-enterprise/mint-app/pkg/authentication"
	"github.com/cms-enterprise/mint-app/pkg/models"
	"github.com/cms-enterprise/mint-app/pkg/storage"
	"github.com/cms-enterprise/mint-app/pkg/storage/loaders"
)

// MTOInfoGetByModelPlanIDLOADER implements resolver logic to get all mto info records for an modelPlanID (which is the same as the id in this case)
func MTOInfoGetByModelPlanIDLOADER(ctx context.Context, modelPlanID uuid.UUID) (*models.MTOInfo, error) {
	return loaders.MTOInfo.ByModelPlanID.Load(ctx, modelPlanID)
}

// MTOInfoUpdate takes a changes object and updates an MTO info object
func MTOInfoUpdate(ctx context.Context, logger *zap.Logger, id uuid.UUID, changes map[string]interface{}, principal authentication.Principal, store *storage.Store) (*models.MTOInfo, error) {
	// Get existing record
	existingRecord, err := MTOInfoGetByModelPlanIDLOADER(ctx, id)
	if err != nil {
		return nil, err
	}
	//TODO (mto) this is a bit of a departure, note this function will fail if a data loader  is not initiated
	//TODO (mto) do we even want to expose this? Or should we just leave the specific mutation to toggle ready for review

	err = BaseStructPreUpdate(logger, existingRecord, changes, principal, store, true, true)
	if err != nil {
		return nil, err
	}

	returnedRecord, err := storage.MTOInfoUpdate(store, logger, existingRecord)
	if err != nil {
		return nil, err
	}
	return returnedRecord, err
}
